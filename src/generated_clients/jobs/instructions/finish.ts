/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from "@solana/kit";
import { NOSANA_JOBS_PROGRAM_ADDRESS } from "../programs/index.js";
import { getAccountMetaFactory, type ResolvedAccount } from "../shared/index.js";

export const FINISH_INSTRUCTION_ACCOUNTS = {
  job: 0,
  run: 1,
  market: 2,
  vault: 3,
  deposit: 4,
  user: 5,
  payerJob: 6,
  payerRun: 7,
  project: 8,
  authority: 9,
  tokenProgram: 10,
} as const;

export type FinishInstructionAccountName = keyof typeof FINISH_INSTRUCTION_ACCOUNTS;
export const FINISH_DISCRIMINATOR = new Uint8Array([
  67, 74, 170, 132, 125, 233, 182, 37,
]);

export function getFinishDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(FINISH_DISCRIMINATOR);
}

export type FinishInstruction<
  TProgram extends string = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
  TAccountJob extends string | AccountMeta<string> = string,
  TAccountRun extends string | AccountMeta<string> = string,
  TAccountMarket extends string | AccountMeta<string> = string,
  TAccountVault extends string | AccountMeta<string> = string,
  TAccountDeposit extends string | AccountMeta<string> = string,
  TAccountUser extends string | AccountMeta<string> = string,
  TAccountPayerJob extends string | AccountMeta<string> = string,
  TAccountPayerRun extends string | AccountMeta<string> = string,
  TAccountProject extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> =
    "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountJob extends string ? WritableAccount<TAccountJob> : TAccountJob,
      TAccountRun extends string ? WritableAccount<TAccountRun> : TAccountRun,
      TAccountMarket extends string
        ? ReadonlyAccount<TAccountMarket>
        : TAccountMarket,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountDeposit extends string
        ? WritableAccount<TAccountDeposit>
        : TAccountDeposit,
      TAccountUser extends string
        ? WritableAccount<TAccountUser>
        : TAccountUser,
      TAccountPayerJob extends string
        ? WritableAccount<TAccountPayerJob>
        : TAccountPayerJob,
      TAccountPayerRun extends string
        ? WritableAccount<TAccountPayerRun>
        : TAccountPayerRun,
      TAccountProject extends string
        ? WritableAccount<TAccountProject>
        : TAccountProject,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            AccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type FinishInstructionData = {
  discriminator: ReadonlyUint8Array;
  ipfsResult: ReadonlyUint8Array;
};

export type FinishInstructionDataArgs = { ipfsResult: ReadonlyUint8Array };

export function getFinishInstructionDataEncoder(): FixedSizeEncoder<FinishInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["ipfsResult", fixEncoderSize(getBytesEncoder(), 32)],
    ]),
    (value) => ({ ...value, discriminator: FINISH_DISCRIMINATOR }),
  );
}

export function getFinishInstructionDataDecoder(): FixedSizeDecoder<FinishInstructionData> {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["ipfsResult", fixDecoderSize(getBytesDecoder(), 32)],
  ]);
}

export function getFinishInstructionDataCodec(): FixedSizeCodec<
  FinishInstructionDataArgs,
  FinishInstructionData
> {
  return combineCodec(
    getFinishInstructionDataEncoder(),
    getFinishInstructionDataDecoder(),
  );
}

export type FinishInput<
  TAccountJob extends string = string,
  TAccountRun extends string = string,
  TAccountMarket extends string = string,
  TAccountVault extends string = string,
  TAccountDeposit extends string = string,
  TAccountUser extends string = string,
  TAccountPayerJob extends string = string,
  TAccountPayerRun extends string = string,
  TAccountProject extends string = string,
  TAccountAuthority extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  job: Address<TAccountJob>;
  run: Address<TAccountRun>;
  market: Address<TAccountMarket>;
  vault: Address<TAccountVault>;
  deposit: Address<TAccountDeposit>;
  user: Address<TAccountUser>;
  payerJob: Address<TAccountPayerJob>;
  payerRun: Address<TAccountPayerRun>;
  project: Address<TAccountProject>;
  authority: TransactionSigner<TAccountAuthority>;
  tokenProgram?: Address<TAccountTokenProgram>;
  ipfsResult: FinishInstructionDataArgs["ipfsResult"];
};

export function getFinishInstruction<
  TAccountJob extends string,
  TAccountRun extends string,
  TAccountMarket extends string,
  TAccountVault extends string,
  TAccountDeposit extends string,
  TAccountUser extends string,
  TAccountPayerJob extends string,
  TAccountPayerRun extends string,
  TAccountProject extends string,
  TAccountAuthority extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
>(
  input: FinishInput<
    TAccountJob,
    TAccountRun,
    TAccountMarket,
    TAccountVault,
    TAccountDeposit,
    TAccountUser,
    TAccountPayerJob,
    TAccountPayerRun,
    TAccountProject,
    TAccountAuthority,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress },
): FinishInstruction<
  TProgramAddress,
  TAccountJob,
  TAccountRun,
  TAccountMarket,
  TAccountVault,
  TAccountDeposit,
  TAccountUser,
  TAccountPayerJob,
  TAccountPayerRun,
  TAccountProject,
  TAccountAuthority,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? NOSANA_JOBS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    job: { value: input.job ?? null, isWritable: true },
    run: { value: input.run ?? null, isWritable: true },
    market: { value: input.market ?? null, isWritable: false },
    vault: { value: input.vault ?? null, isWritable: true },
    deposit: { value: input.deposit ?? null, isWritable: true },
    user: { value: input.user ?? null, isWritable: true },
    payerJob: { value: input.payerJob ?? null, isWritable: true },
    payerRun: { value: input.payerRun ?? null, isWritable: true },
    project: { value: input.project ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA" as Address<"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA">;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.job),
      getAccountMeta(accounts.run),
      getAccountMeta(accounts.market),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.deposit),
      getAccountMeta(accounts.user),
      getAccountMeta(accounts.payerJob),
      getAccountMeta(accounts.payerRun),
      getAccountMeta(accounts.project),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getFinishInstructionDataEncoder().encode(
      args as FinishInstructionDataArgs,
    ),
    programAddress,
  } as FinishInstruction<
    TProgramAddress,
    TAccountJob,
    TAccountRun,
    TAccountMarket,
    TAccountVault,
    TAccountDeposit,
    TAccountUser,
    TAccountPayerJob,
    TAccountPayerRun,
    TAccountProject,
    TAccountAuthority,
    TAccountTokenProgram
  >);
}

export type ParsedFinishInstruction<
  TProgram extends string = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    job: TAccountMetas[0];
    run: TAccountMetas[1];
    market: TAccountMetas[2];
    vault: TAccountMetas[3];
    deposit: TAccountMetas[4];
    user: TAccountMetas[5];
    payerJob: TAccountMetas[6];
    payerRun: TAccountMetas[7];
    project: TAccountMetas[8];
    authority: TAccountMetas[9];
    tokenProgram: TAccountMetas[10];
  };
  data: FinishInstructionData;
};

export function parseFinishInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>,
): ParsedFinishInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      job: getNextAccount(),
      run: getNextAccount(),
      market: getNextAccount(),
      vault: getNextAccount(),
      deposit: getNextAccount(),
      user: getNextAccount(),
      payerJob: getNextAccount(),
      payerRun: getNextAccount(),
      project: getNextAccount(),
      authority: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getFinishInstructionDataDecoder().decode(instruction.data),
  };
}
