/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { NOSANA_JOBS_PROGRAM_ADDRESS } from '../programs/index.js';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared/index.js';

export const EXTEND_INSTRUCTION_ACCOUNTS = {
  job: 0,
  market: 1,
  user: 2,
  vault: 3,
  rewardsReflection: 4,
  rewardsVault: 5,
  authority: 6,
  payer: 7,
  rewardsProgram: 8,
  tokenProgram: 9,
} as const;

export type ExtendInstructionAccountName = keyof typeof EXTEND_INSTRUCTION_ACCOUNTS;
export const EXTEND_DISCRIMINATOR = new Uint8Array([
  228, 127, 0, 1, 227, 154, 54, 168,
]);

export function getExtendDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(EXTEND_DISCRIMINATOR);
}

export type ExtendInstruction<
  TProgram extends string = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
  TAccountJob extends string | AccountMeta<string> = string,
  TAccountMarket extends string | AccountMeta<string> = string,
  TAccountUser extends string | AccountMeta<string> = string,
  TAccountVault extends string | AccountMeta<string> = string,
  TAccountRewardsReflection extends string | AccountMeta<string> = string,
  TAccountRewardsVault extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountPayer extends string | AccountMeta<string> = string,
  TAccountRewardsProgram extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountJob extends string ? WritableAccount<TAccountJob> : TAccountJob,
      TAccountMarket extends string
        ? ReadonlyAccount<TAccountMarket>
        : TAccountMarket,
      TAccountUser extends string
        ? WritableAccount<TAccountUser>
        : TAccountUser,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountRewardsReflection extends string
        ? WritableAccount<TAccountRewardsReflection>
        : TAccountRewardsReflection,
      TAccountRewardsVault extends string
        ? WritableAccount<TAccountRewardsVault>
        : TAccountRewardsVault,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            AccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountPayer extends string
        ? ReadonlySignerAccount<TAccountPayer> &
            AccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountRewardsProgram extends string
        ? ReadonlyAccount<TAccountRewardsProgram>
        : TAccountRewardsProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type ExtendInstructionData = {
  discriminator: ReadonlyUint8Array;
  timeout: bigint;
};

export type ExtendInstructionDataArgs = { timeout: number | bigint };

export function getExtendInstructionDataEncoder(): FixedSizeEncoder<ExtendInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['timeout', getI64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: EXTEND_DISCRIMINATOR })
  );
}

export function getExtendInstructionDataDecoder(): FixedSizeDecoder<ExtendInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['timeout', getI64Decoder()],
  ]);
}

export function getExtendInstructionDataCodec(): FixedSizeCodec<
  ExtendInstructionDataArgs,
  ExtendInstructionData
> {
  return combineCodec(
    getExtendInstructionDataEncoder(),
    getExtendInstructionDataDecoder()
  );
}

export type ExtendInput<
  TAccountJob extends string = string,
  TAccountMarket extends string = string,
  TAccountUser extends string = string,
  TAccountVault extends string = string,
  TAccountRewardsReflection extends string = string,
  TAccountRewardsVault extends string = string,
  TAccountAuthority extends string = string,
  TAccountPayer extends string = string,
  TAccountRewardsProgram extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  job: Address<TAccountJob>;
  market: Address<TAccountMarket>;
  user: Address<TAccountUser>;
  vault: Address<TAccountVault>;
  rewardsReflection: Address<TAccountRewardsReflection>;
  rewardsVault: Address<TAccountRewardsVault>;
  authority: TransactionSigner<TAccountAuthority>;
  payer: TransactionSigner<TAccountPayer>;
  rewardsProgram: Address<TAccountRewardsProgram>;
  tokenProgram?: Address<TAccountTokenProgram>;
  timeout: ExtendInstructionDataArgs['timeout'];
};

export function getExtendInstruction<
  TAccountJob extends string,
  TAccountMarket extends string,
  TAccountUser extends string,
  TAccountVault extends string,
  TAccountRewardsReflection extends string,
  TAccountRewardsVault extends string,
  TAccountAuthority extends string,
  TAccountPayer extends string,
  TAccountRewardsProgram extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
>(
  input: ExtendInput<
    TAccountJob,
    TAccountMarket,
    TAccountUser,
    TAccountVault,
    TAccountRewardsReflection,
    TAccountRewardsVault,
    TAccountAuthority,
    TAccountPayer,
    TAccountRewardsProgram,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): ExtendInstruction<
  TProgramAddress,
  TAccountJob,
  TAccountMarket,
  TAccountUser,
  TAccountVault,
  TAccountRewardsReflection,
  TAccountRewardsVault,
  TAccountAuthority,
  TAccountPayer,
  TAccountRewardsProgram,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? NOSANA_JOBS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    job: { value: input.job ?? null, isWritable: true },
    market: { value: input.market ?? null, isWritable: false },
    user: { value: input.user ?? null, isWritable: true },
    vault: { value: input.vault ?? null, isWritable: true },
    rewardsReflection: {
      value: input.rewardsReflection ?? null,
      isWritable: true,
    },
    rewardsVault: { value: input.rewardsVault ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: false },
    rewardsProgram: { value: input.rewardsProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.job),
      getAccountMeta(accounts.market),
      getAccountMeta(accounts.user),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.rewardsReflection),
      getAccountMeta(accounts.rewardsVault),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.rewardsProgram),
      getAccountMeta(accounts.tokenProgram),
    ],
    data: getExtendInstructionDataEncoder().encode(
      args as ExtendInstructionDataArgs
    ),
    programAddress,
  } as ExtendInstruction<
    TProgramAddress,
    TAccountJob,
    TAccountMarket,
    TAccountUser,
    TAccountVault,
    TAccountRewardsReflection,
    TAccountRewardsVault,
    TAccountAuthority,
    TAccountPayer,
    TAccountRewardsProgram,
    TAccountTokenProgram
  >);
}

export type ParsedExtendInstruction<
  TProgram extends string = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    job: TAccountMetas[0];
    market: TAccountMetas[1];
    user: TAccountMetas[2];
    vault: TAccountMetas[3];
    rewardsReflection: TAccountMetas[4];
    rewardsVault: TAccountMetas[5];
    authority: TAccountMetas[6];
    payer: TAccountMetas[7];
    rewardsProgram: TAccountMetas[8];
    tokenProgram: TAccountMetas[9];
  };
  data: ExtendInstructionData;
};

export function parseExtendInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedExtendInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      job: getNextAccount(),
      market: getNextAccount(),
      user: getNextAccount(),
      vault: getNextAccount(),
      rewardsReflection: getNextAccount(),
      rewardsVault: getNextAccount(),
      authority: getNextAccount(),
      payer: getNextAccount(),
      rewardsProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getExtendInstructionDataDecoder().decode(instruction.data),
  };
}
