/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  isProgramError,
  type Address,
  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,
  type SolanaError,
} from '@solana/kit';
import { MERKLE_DISTRIBUTOR_PROGRAM_ADDRESS } from '../programs';

/** InsufficientUnlockedTokens: Insufficient unlocked tokens */
export const MERKLE_DISTRIBUTOR_ERROR__INSUFFICIENT_UNLOCKED_TOKENS = 0x1770; // 6000
/** StartTooFarInFuture: Deposit Start too far in future */
export const MERKLE_DISTRIBUTOR_ERROR__START_TOO_FAR_IN_FUTURE = 0x1771; // 6001
/** InvalidProof: Invalid Merkle proof. */
export const MERKLE_DISTRIBUTOR_ERROR__INVALID_PROOF = 0x1772; // 6002
/** ExceededMaxClaim: Exceeded maximum claim amount */
export const MERKLE_DISTRIBUTOR_ERROR__EXCEEDED_MAX_CLAIM = 0x1773; // 6003
/** MaxNodesExceeded: Exceeded maximum node count */
export const MERKLE_DISTRIBUTOR_ERROR__MAX_NODES_EXCEEDED = 0x1774; // 6004
/** Unauthorized: Account is not authorized to execute this instruction */
export const MERKLE_DISTRIBUTOR_ERROR__UNAUTHORIZED = 0x1775; // 6005
/** OwnerMismatch: Token account owner did not match intended owner */
export const MERKLE_DISTRIBUTOR_ERROR__OWNER_MISMATCH = 0x1776; // 6006
/** ClawbackDuringVesting: Clawback cannot be before vesting ends */
export const MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_DURING_VESTING = 0x1777; // 6007
/** ClawbackBeforeStart: Attempted clawback before start */
export const MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_BEFORE_START = 0x1778; // 6008
/** ClawbackAlreadyClaimed: Clawback already claimed */
export const MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_ALREADY_CLAIMED = 0x1779; // 6009
/** InsufficientClawbackDelay: Clawback start must be at least one day after vesting end */
export const MERKLE_DISTRIBUTOR_ERROR__INSUFFICIENT_CLAWBACK_DELAY = 0x177a; // 6010
/** SameClawbackReceiver: New and old Clawback receivers are identical */
export const MERKLE_DISTRIBUTOR_ERROR__SAME_CLAWBACK_RECEIVER = 0x177b; // 6011
/** SameAdmin: New and old admin are identical */
export const MERKLE_DISTRIBUTOR_ERROR__SAME_ADMIN = 0x177c; // 6012
/** ClaimExpired: Claim window expired */
export const MERKLE_DISTRIBUTOR_ERROR__CLAIM_EXPIRED = 0x177d; // 6013
/** ArithmeticError: Arithmetic Error (overflow/underflow) */
export const MERKLE_DISTRIBUTOR_ERROR__ARITHMETIC_ERROR = 0x177e; // 6014
/** StartTimestampAfterEnd: Start Timestamp cannot be after end Timestamp */
export const MERKLE_DISTRIBUTOR_ERROR__START_TIMESTAMP_AFTER_END = 0x177f; // 6015
/** TimestampsNotInFuture: Timestamps cannot be in the past */
export const MERKLE_DISTRIBUTOR_ERROR__TIMESTAMPS_NOT_IN_FUTURE = 0x1780; // 6016
/** InvalidVersion: Airdrop Version Mismatch */
export const MERKLE_DISTRIBUTOR_ERROR__INVALID_VERSION = 0x1781; // 6017
/** ClaimingIsNotStarted: Claiming is not started */
export const MERKLE_DISTRIBUTOR_ERROR__CLAIMING_IS_NOT_STARTED = 0x1782; // 6018
/** CannotCloseDistributor: Cannot close distributor */
export const MERKLE_DISTRIBUTOR_ERROR__CANNOT_CLOSE_DISTRIBUTOR = 0x1783; // 6019
/** CannotCloseClaimStatus: Cannot close claim status */
export const MERKLE_DISTRIBUTOR_ERROR__CANNOT_CLOSE_CLAIM_STATUS = 0x1784; // 6020
/** InvalidVote: Can only claim to vote address */
export const MERKLE_DISTRIBUTOR_ERROR__INVALID_VOTE = 0x1785; // 6021

export type MerkleDistributorError =
  | typeof MERKLE_DISTRIBUTOR_ERROR__ARITHMETIC_ERROR
  | typeof MERKLE_DISTRIBUTOR_ERROR__CANNOT_CLOSE_CLAIM_STATUS
  | typeof MERKLE_DISTRIBUTOR_ERROR__CANNOT_CLOSE_DISTRIBUTOR
  | typeof MERKLE_DISTRIBUTOR_ERROR__CLAIM_EXPIRED
  | typeof MERKLE_DISTRIBUTOR_ERROR__CLAIMING_IS_NOT_STARTED
  | typeof MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_ALREADY_CLAIMED
  | typeof MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_BEFORE_START
  | typeof MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_DURING_VESTING
  | typeof MERKLE_DISTRIBUTOR_ERROR__EXCEEDED_MAX_CLAIM
  | typeof MERKLE_DISTRIBUTOR_ERROR__INSUFFICIENT_CLAWBACK_DELAY
  | typeof MERKLE_DISTRIBUTOR_ERROR__INSUFFICIENT_UNLOCKED_TOKENS
  | typeof MERKLE_DISTRIBUTOR_ERROR__INVALID_PROOF
  | typeof MERKLE_DISTRIBUTOR_ERROR__INVALID_VERSION
  | typeof MERKLE_DISTRIBUTOR_ERROR__INVALID_VOTE
  | typeof MERKLE_DISTRIBUTOR_ERROR__MAX_NODES_EXCEEDED
  | typeof MERKLE_DISTRIBUTOR_ERROR__OWNER_MISMATCH
  | typeof MERKLE_DISTRIBUTOR_ERROR__SAME_ADMIN
  | typeof MERKLE_DISTRIBUTOR_ERROR__SAME_CLAWBACK_RECEIVER
  | typeof MERKLE_DISTRIBUTOR_ERROR__START_TIMESTAMP_AFTER_END
  | typeof MERKLE_DISTRIBUTOR_ERROR__START_TOO_FAR_IN_FUTURE
  | typeof MERKLE_DISTRIBUTOR_ERROR__TIMESTAMPS_NOT_IN_FUTURE
  | typeof MERKLE_DISTRIBUTOR_ERROR__UNAUTHORIZED;

let merkleDistributorErrorMessages:
  | Record<MerkleDistributorError, string>
  | undefined;
if (process.env.NODE_ENV !== 'production') {
  merkleDistributorErrorMessages = {
    [MERKLE_DISTRIBUTOR_ERROR__ARITHMETIC_ERROR]: `Arithmetic Error (overflow/underflow)`,
    [MERKLE_DISTRIBUTOR_ERROR__CANNOT_CLOSE_CLAIM_STATUS]: `Cannot close claim status`,
    [MERKLE_DISTRIBUTOR_ERROR__CANNOT_CLOSE_DISTRIBUTOR]: `Cannot close distributor`,
    [MERKLE_DISTRIBUTOR_ERROR__CLAIM_EXPIRED]: `Claim window expired`,
    [MERKLE_DISTRIBUTOR_ERROR__CLAIMING_IS_NOT_STARTED]: `Claiming is not started`,
    [MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_ALREADY_CLAIMED]: `Clawback already claimed`,
    [MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_BEFORE_START]: `Attempted clawback before start`,
    [MERKLE_DISTRIBUTOR_ERROR__CLAWBACK_DURING_VESTING]: `Clawback cannot be before vesting ends`,
    [MERKLE_DISTRIBUTOR_ERROR__EXCEEDED_MAX_CLAIM]: `Exceeded maximum claim amount`,
    [MERKLE_DISTRIBUTOR_ERROR__INSUFFICIENT_CLAWBACK_DELAY]: `Clawback start must be at least one day after vesting end`,
    [MERKLE_DISTRIBUTOR_ERROR__INSUFFICIENT_UNLOCKED_TOKENS]: `Insufficient unlocked tokens`,
    [MERKLE_DISTRIBUTOR_ERROR__INVALID_PROOF]: `Invalid Merkle proof.`,
    [MERKLE_DISTRIBUTOR_ERROR__INVALID_VERSION]: `Airdrop Version Mismatch`,
    [MERKLE_DISTRIBUTOR_ERROR__INVALID_VOTE]: `Can only claim to vote address`,
    [MERKLE_DISTRIBUTOR_ERROR__MAX_NODES_EXCEEDED]: `Exceeded maximum node count`,
    [MERKLE_DISTRIBUTOR_ERROR__OWNER_MISMATCH]: `Token account owner did not match intended owner`,
    [MERKLE_DISTRIBUTOR_ERROR__SAME_ADMIN]: `New and old admin are identical`,
    [MERKLE_DISTRIBUTOR_ERROR__SAME_CLAWBACK_RECEIVER]: `New and old Clawback receivers are identical`,
    [MERKLE_DISTRIBUTOR_ERROR__START_TIMESTAMP_AFTER_END]: `Start Timestamp cannot be after end Timestamp`,
    [MERKLE_DISTRIBUTOR_ERROR__START_TOO_FAR_IN_FUTURE]: `Deposit Start too far in future`,
    [MERKLE_DISTRIBUTOR_ERROR__TIMESTAMPS_NOT_IN_FUTURE]: `Timestamps cannot be in the past`,
    [MERKLE_DISTRIBUTOR_ERROR__UNAUTHORIZED]: `Account is not authorized to execute this instruction`,
  };
}

export function getMerkleDistributorErrorMessage(
  code: MerkleDistributorError
): string {
  if (process.env.NODE_ENV !== 'production') {
    return (
      merkleDistributorErrorMessages as Record<MerkleDistributorError, string>
    )[code];
  }

  return 'Error message not available in production bundles.';
}

export function isMerkleDistributorError<
  TProgramErrorCode extends MerkleDistributorError,
>(
  error: unknown,
  transactionMessage: {
    instructions: Record<number, { programAddress: Address }>;
  },
  code?: TProgramErrorCode
): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &
  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {
  return isProgramError<TProgramErrorCode>(
    error,
    transactionMessage,
    MERKLE_DISTRIBUTOR_PROGRAM_ADDRESS,
    code
  );
}
