/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  type ParsedClaimLockedInstruction,
  type ParsedClawbackInstruction,
  type ParsedCloseClaimStatusInstruction,
  type ParsedCloseDistributorInstruction,
  type ParsedNewClaimInstruction,
  type ParsedNewDistributorInstruction,
  type ParsedSetAdminInstruction,
  type ParsedSetClawbackReceiverInstruction,
  type ParsedSetEnableSlotInstruction,
} from "../instructions/index.js";

export const MERKLE_DISTRIBUTOR_PROGRAM_ADDRESS =
  "merkp8F8f5EgYSYKadk3YiuQQdo3JPdnJWKviaaF425" as Address<"merkp8F8f5EgYSYKadk3YiuQQdo3JPdnJWKviaaF425">;

export const MerkleDistributorAccount = {
  ClaimStatus: "ClaimStatus",
  MerkleDistributor: "MerkleDistributor",
} as const;
export type MerkleDistributorAccount = (typeof MerkleDistributorAccount)[keyof typeof MerkleDistributorAccount];

export function identifyMerkleDistributorAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): MerkleDistributorAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([22, 183, 249, 157, 247, 95, 150, 96]),
      ),
      0,
    )
  ) {
    return MerkleDistributorAccount.ClaimStatus;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([77, 119, 139, 70, 84, 247, 12, 26]),
      ),
      0,
    )
  ) {
    return MerkleDistributorAccount.MerkleDistributor;
  }
  throw new Error(
    "The provided account could not be identified as a merkleDistributor account.",
  );
}

export const MerkleDistributorInstruction = {
  NewDistributor: "NewDistributor",
  CloseDistributor: "CloseDistributor",
  CloseClaimStatus: "CloseClaimStatus",
  SetEnableSlot: "SetEnableSlot",
  NewClaim: "NewClaim",
  ClaimLocked: "ClaimLocked",
  Clawback: "Clawback",
  SetClawbackReceiver: "SetClawbackReceiver",
  SetAdmin: "SetAdmin",
} as const;
export type MerkleDistributorInstruction = (typeof MerkleDistributorInstruction)[keyof typeof MerkleDistributorInstruction];

export function identifyMerkleDistributorInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): MerkleDistributorInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([32, 139, 112, 171, 0, 2, 225, 155]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.NewDistributor;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([202, 56, 180, 143, 46, 104, 106, 112]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.CloseDistributor;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([163, 214, 191, 165, 245, 188, 17, 185]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.CloseClaimStatus;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([5, 52, 73, 33, 150, 115, 97, 206]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.SetEnableSlot;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([78, 177, 98, 123, 210, 21, 187, 83]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.NewClaim;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([34, 206, 181, 23, 11, 207, 147, 90]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.ClaimLocked;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([111, 92, 142, 79, 33, 234, 82, 27]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.Clawback;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([153, 217, 34, 20, 19, 29, 229, 75]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.SetClawbackReceiver;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([251, 163, 0, 52, 91, 194, 187, 92]),
      ),
      0,
    )
  ) {
    return MerkleDistributorInstruction.SetAdmin;
  }
  throw new Error(
    "The provided instruction could not be identified as a merkleDistributor instruction.",
  );
}

export type ParsedMerkleDistributorInstruction<
  TProgram extends string = "merkp8F8f5EgYSYKadk3YiuQQdo3JPdnJWKviaaF425",
> =
  | ({
      instructionType: typeof MerkleDistributorInstruction.NewDistributor;
    } & ParsedNewDistributorInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.CloseDistributor;
    } & ParsedCloseDistributorInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.CloseClaimStatus;
    } & ParsedCloseClaimStatusInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.SetEnableSlot;
    } & ParsedSetEnableSlotInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.NewClaim;
    } & ParsedNewClaimInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.ClaimLocked;
    } & ParsedClaimLockedInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.Clawback;
    } & ParsedClawbackInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.SetClawbackReceiver;
    } & ParsedSetClawbackReceiverInstruction<TProgram>)
  | ({
      instructionType: typeof MerkleDistributorInstruction.SetAdmin;
    } & ParsedSetAdminInstruction<TProgram>);
