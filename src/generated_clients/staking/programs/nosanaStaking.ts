/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedCloseInstruction,
  type ParsedExtendInstruction,
  type ParsedInitInstruction,
  type ParsedRestakeInstruction,
  type ParsedSlashInstruction,
  type ParsedStakeInstruction,
  type ParsedTopupInstruction,
  type ParsedUnstakeInstruction,
  type ParsedUpdateSettingsInstruction,
  type ParsedWithdrawInstruction,
} from '../instructions/index.js';

export const NOSANA_STAKING_PROGRAM_ADDRESS = '' as Address<''>;

export const NosanaStakingAccount = {
  SettingsAccount: "SettingsAccount",
  StakeAccount: "StakeAccount",
} as const;
export type NosanaStakingAccount = (typeof NosanaStakingAccount)[keyof typeof NosanaStakingAccount];

export function identifyNosanaStakingAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): NosanaStakingAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([63, 89, 203, 155, 76, 237, 115, 58])
      ),
      0
    )
  ) {
    return NosanaStakingAccount.SettingsAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([80, 158, 67, 124, 50, 189, 192, 255])
      ),
      0
    )
  ) {
    return NosanaStakingAccount.StakeAccount;
  }
  throw new Error(
    'The provided account could not be identified as a nosanaStaking account.'
  );
}

export const NosanaStakingInstruction = {
  Init: "Init",
  Stake: "Stake",
  Unstake: "Unstake",
  Restake: "Restake",
  Topup: "Topup",
  Extend: "Extend",
  Close: "Close",
  Withdraw: "Withdraw",
  Slash: "Slash",
  UpdateSettings: "UpdateSettings",
} as const;
export type NosanaStakingInstruction = (typeof NosanaStakingInstruction)[keyof typeof NosanaStakingInstruction];

export function identifyNosanaStakingInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): NosanaStakingInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Init;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([206, 176, 202, 18, 200, 209, 179, 108])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Stake;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 95, 107, 42, 205, 124, 50, 225])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Unstake;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([97, 161, 241, 167, 6, 32, 213, 53])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Restake;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([126, 42, 49, 78, 225, 151, 99, 77])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Topup;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([228, 127, 0, 1, 227, 154, 54, 168])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Extend;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([98, 165, 201, 177, 108, 65, 206, 96])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Close;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([183, 18, 70, 156, 148, 109, 161, 34])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Withdraw;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([204, 141, 18, 161, 8, 177, 92, 142])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.Slash;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([81, 166, 51, 213, 158, 84, 157, 108])
      ),
      0
    )
  ) {
    return NosanaStakingInstruction.UpdateSettings;
  }
  throw new Error(
    'The provided instruction could not be identified as a nosanaStaking instruction.'
  );
}

export type ParsedNosanaStakingInstruction<TProgram extends string = ''> =
  | ({
      instructionType: typeof NosanaStakingInstruction.Init;
    } & ParsedInitInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Stake;
    } & ParsedStakeInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Unstake;
    } & ParsedUnstakeInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Restake;
    } & ParsedRestakeInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Topup;
    } & ParsedTopupInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Extend;
    } & ParsedExtendInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Close;
    } & ParsedCloseInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Withdraw;
    } & ParsedWithdrawInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.Slash;
    } & ParsedSlashInstruction<TProgram>)
  | ({
      instructionType: typeof NosanaStakingInstruction.UpdateSettings;
    } & ParsedUpdateSettingsInstruction<TProgram>);
