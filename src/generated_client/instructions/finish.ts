/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { NOSANA_JOBS_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const FINISH_DISCRIMINATOR = new Uint8Array([
  67, 74, 170, 132, 125, 233, 182, 37,
]);

export function getFinishDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(FINISH_DISCRIMINATOR);
}

export type FinishInstruction<
  TProgram extends string = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
  TAccountJob extends string | IAccountMeta<string> = string,
  TAccountRun extends string | IAccountMeta<string> = string,
  TAccountMarket extends string | IAccountMeta<string> = string,
  TAccountVault extends string | IAccountMeta<string> = string,
  TAccountDeposit extends string | IAccountMeta<string> = string,
  TAccountUser extends string | IAccountMeta<string> = string,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountProject extends string | IAccountMeta<string> = string,
  TAccountAuthority extends string | IAccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountJob extends string ? WritableAccount<TAccountJob> : TAccountJob,
      TAccountRun extends string ? WritableAccount<TAccountRun> : TAccountRun,
      TAccountMarket extends string
        ? ReadonlyAccount<TAccountMarket>
        : TAccountMarket,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountDeposit extends string
        ? WritableAccount<TAccountDeposit>
        : TAccountDeposit,
      TAccountUser extends string
        ? WritableAccount<TAccountUser>
        : TAccountUser,
      TAccountPayer extends string
        ? WritableAccount<TAccountPayer>
        : TAccountPayer,
      TAccountProject extends string
        ? WritableAccount<TAccountProject>
        : TAccountProject,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            IAccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type FinishInstructionData = {
  discriminator: ReadonlyUint8Array;
  ipfsResult: ReadonlyUint8Array;
};

export type FinishInstructionDataArgs = { ipfsResult: ReadonlyUint8Array };

export function getFinishInstructionDataEncoder(): Encoder<FinishInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['ipfsResult', fixEncoderSize(getBytesEncoder(), 32)],
    ]),
    (value) => ({ ...value, discriminator: FINISH_DISCRIMINATOR })
  );
}

export function getFinishInstructionDataDecoder(): Decoder<FinishInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['ipfsResult', fixDecoderSize(getBytesDecoder(), 32)],
  ]);
}

export function getFinishInstructionDataCodec(): Codec<
  FinishInstructionDataArgs,
  FinishInstructionData
> {
  return combineCodec(
    getFinishInstructionDataEncoder(),
    getFinishInstructionDataDecoder()
  );
}

export type FinishInput<
  TAccountJob extends string = string,
  TAccountRun extends string = string,
  TAccountMarket extends string = string,
  TAccountVault extends string = string,
  TAccountDeposit extends string = string,
  TAccountUser extends string = string,
  TAccountPayer extends string = string,
  TAccountProject extends string = string,
  TAccountAuthority extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  job: Address<TAccountJob>;
  run: Address<TAccountRun>;
  market: Address<TAccountMarket>;
  vault: Address<TAccountVault>;
  deposit: Address<TAccountDeposit>;
  user: Address<TAccountUser>;
  payer: Address<TAccountPayer>;
  project: Address<TAccountProject>;
  authority: TransactionSigner<TAccountAuthority>;
  tokenProgram?: Address<TAccountTokenProgram>;
  ipfsResult: FinishInstructionDataArgs['ipfsResult'];
};

export function getFinishInstruction<
  TAccountJob extends string,
  TAccountRun extends string,
  TAccountMarket extends string,
  TAccountVault extends string,
  TAccountDeposit extends string,
  TAccountUser extends string,
  TAccountPayer extends string,
  TAccountProject extends string,
  TAccountAuthority extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
>(
  input: FinishInput<
    TAccountJob,
    TAccountRun,
    TAccountMarket,
    TAccountVault,
    TAccountDeposit,
    TAccountUser,
    TAccountPayer,
    TAccountProject,
    TAccountAuthority,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): FinishInstruction<
  TProgramAddress,
  TAccountJob,
  TAccountRun,
  TAccountMarket,
  TAccountVault,
  TAccountDeposit,
  TAccountUser,
  TAccountPayer,
  TAccountProject,
  TAccountAuthority,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? NOSANA_JOBS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    job: { value: input.job ?? null, isWritable: true },
    run: { value: input.run ?? null, isWritable: true },
    market: { value: input.market ?? null, isWritable: false },
    vault: { value: input.vault ?? null, isWritable: true },
    deposit: { value: input.deposit ?? null, isWritable: true },
    user: { value: input.user ?? null, isWritable: true },
    payer: { value: input.payer ?? null, isWritable: true },
    project: { value: input.project ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.job),
      getAccountMeta(accounts.run),
      getAccountMeta(accounts.market),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.deposit),
      getAccountMeta(accounts.user),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.project),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getFinishInstructionDataEncoder().encode(
      args as FinishInstructionDataArgs
    ),
  } as FinishInstruction<
    TProgramAddress,
    TAccountJob,
    TAccountRun,
    TAccountMarket,
    TAccountVault,
    TAccountDeposit,
    TAccountUser,
    TAccountPayer,
    TAccountProject,
    TAccountAuthority,
    TAccountTokenProgram
  >;

  return instruction;
}

export type ParsedFinishInstruction<
  TProgram extends string = typeof NOSANA_JOBS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    job: TAccountMetas[0];
    run: TAccountMetas[1];
    market: TAccountMetas[2];
    vault: TAccountMetas[3];
    deposit: TAccountMetas[4];
    user: TAccountMetas[5];
    payer: TAccountMetas[6];
    project: TAccountMetas[7];
    authority: TAccountMetas[8];
    tokenProgram: TAccountMetas[9];
  };
  data: FinishInstructionData;
};

export function parseFinishInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedFinishInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 10) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      job: getNextAccount(),
      run: getNextAccount(),
      market: getNextAccount(),
      vault: getNextAccount(),
      deposit: getNextAccount(),
      user: getNextAccount(),
      payer: getNextAccount(),
      project: getNextAccount(),
      authority: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getFinishInstructionDataDecoder().decode(instruction.data),
  };
}
